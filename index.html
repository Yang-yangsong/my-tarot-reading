<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarot - Real Reading</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: none; font-family: "Microsoft YaHei", sans-serif; }
        
        #debug-console { position: absolute; bottom: 10px; left: 10px; width: 300px; max-height: 100px; background: rgba(0,0,0,0.5); color: #444; font-size: 10px; pointer-events: none; overflow: hidden; border: none; }

        /* å·¦ä¸Šè§’ UI å¸ƒå±€ */
        #ui-container {
            position: absolute; top: 30px; left: 30px; z-index: 10;
            display: flex; flex-direction: column; gap: 10px;
            pointer-events: none;
            max-width: 350px;
        }

        .status-box { 
            border-left: 3px solid #d4af37; background: rgba(0,0,0,0.7); 
            padding: 8px 15px; color: #d4af37; font-size: 12px; 
            letter-spacing: 1px; width: fit-content; backdrop-filter: blur(4px);
        }
        .highlight { color: #fff; font-weight: bold; }

        /* [æ–°å¢] ç‰Œä¹‰è§£è¯»é¢æ¿ */
        #reading-panel {
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(212, 175, 55, 0.5);
            border-radius: 4px;
            padding: 20px;
            opacity: 0;
            transition: opacity 0.5s;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        #reading-title {
            color: #fff; font-size: 24px; font-weight: bold;
            margin-bottom: 5px; border-bottom: 1px solid #d4af37;
            padding-bottom: 10px;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.6);
        }
        #reading-keywords {
            color: #d4af37; font-size: 12px; margin-bottom: 15px; letter-spacing: 1px;
            text-transform: uppercase;
        }
        #reading-text {
            color: #ddd; font-size: 14px; line-height: 1.6;
            text-align: justify;
        }

        /* å†å²è®°å½• */
        #history-panel {
            margin-top: 10px; width: 100%; background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 4px; padding: 10px;
        }
        .history-title { color: #888; font-size: 10px; margin-bottom: 5px; }
        #history-list { list-style: none; padding: 0; margin: 0; max-height: 150px; overflow-y: hidden; display: flex; flex-direction: column-reverse; }
        .history-item { color: #aaa; font-size: 12px; padding: 3px 0; border-bottom: 1px dashed rgba(255,255,255,0.05); display: flex; justify-content: space-between; }

        /* å…‰æ ‡ */
        #hand-cursor { position: absolute; width: 20px; height: 20px; border: 2px solid rgba(255, 255, 255, 0.9); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 999; box-shadow: 0 0 8px rgba(255, 255, 255, 0.4); transition: width 0.1s, height 0.1s, background 0.1s; }
        #hand-cursor.pinch { background: rgba(0, 255, 255, 0.6); width: 12px; height: 12px; border-color: #00ffff; }
        
        .input_video { display: none; }
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 1000; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #d4af37; letter-spacing: 4px; font-size: 14px; transition: opacity 0.5s; }
        .loading-bar { width: 150px; height: 1px; background: #333; margin-top: 20px; }
        .progress { width: 0%; height: 100%; background: #d4af37; transition: width 0.2s; }
    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
          "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.1/dist/tween.esm.js"
        }
      }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="loader"><div>INITIALIZING THE ARCANA...</div><div class="loading-bar"><div class="progress" id="load-progress"></div></div></div>
    
    <div id="debug-console">System Ready.</div>
    <div id="hand-cursor"></div>

    <div id="ui-container">
        <div class="status-box">GESTURE: <span id="gesture-text" class="highlight">NONE</span></div>
        <div class="status-box">ACTION: <span id="action-text" class="highlight">IDLE</span></div>
        
        <div id="reading-panel">
            <div id="reading-title">Card Name</div>
            <div id="reading-keywords">Keywords</div>
            <div id="reading-text">Meaning description...</div>
        </div>

        <div id="history-panel">
            <div class="history-title">HISTORY LOG</div>
            <ul id="history-list"></ul>
        </div>
    </div>

    <video class="input_video"></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js'; 
        import TWEEN from '@tweenjs/tween.js';

        // --- ğŸ”® 78å¼ å¡”ç½—ç‰Œæ•°æ®åº“ ---
        const TAROT_DATA = {
            // å¤§é˜¿å¡çº³ (0-21)
            0: { name: "æ„šäºº (The Fool)", keys: "æ–°çš„å¼€å§‹ã€å†’é™©ã€çº¯çœŸã€æµæµª", desc: "æ„šäººä»£è¡¨æ— é™çš„æ½œåŠ›ã€‚ä½ æ­£ç«™åœ¨æ‚¬å´–è¾¹ç¼˜ï¼Œå‡†å¤‡è¸å…¥æœªçŸ¥çš„æ—…ç¨‹ã€‚è¿™å¯èƒ½æ„å‘³ç€ä¸€ä¸ªæ–°çš„å¼€å§‹ï¼Œæˆ–è€…éœ€è¦ä½ å‡­ç›´è§‰è¡Œäº‹ï¼Œæ”¾ä¸‹ææƒ§ã€‚" },
            1: { name: "é­”æœ¯å¸ˆ (The Magician)", keys: "åˆ›é€ åŠ›ã€æŠ€èƒ½ã€æ„å¿—åŠ›ã€æ˜¾åŒ–", desc: "é­”æœ¯å¸ˆè±¡å¾ç€æ˜¾åŒ–çš„åŠ›é‡ã€‚ä½ æ‹¥æœ‰å®ç°ç›®æ ‡æ‰€éœ€çš„æ‰€æœ‰èµ„æºã€‚ç°åœ¨æ˜¯é‡‡å–è¡ŒåŠ¨ã€åˆ©ç”¨ä½ çš„æŠ€èƒ½å°†æƒ³æ³•å˜ä¸ºç°å®çš„æœ€ä½³æ—¶æœºã€‚" },
            2: { name: "å¥³ç¥­å¸ (High Priestess)", keys: "ç›´è§‰ã€æ½œæ„è¯†ã€ç¥ç§˜ã€å†…åœ¨", desc: "å¥³ç¥­å¸å®ˆæŠ¤ç€æ½œæ„è¯†çš„å¸·å¹•ã€‚è¿™æ˜¯ä¸€ä¸ªå‘å†…çœ‹ã€å€¾å¬ç›´è§‰çš„æ—¶åˆ»ã€‚ç­”æ¡ˆä¸åœ¨å¤–éƒ¨ä¸–ç•Œï¼Œè€Œåœ¨ä½ çš„å†…å¿ƒæ·±å¤„ã€‚" },
            3: { name: "çš‡å (The Empress)", keys: "ä¸°é¥¶ã€æ¯æ€§ã€è‡ªç„¶ã€æ„Ÿå®˜", desc: "çš‡åä»£è¡¨ç€å¯Œè¶³ä¸åˆ›é€ åŠ›ã€‚ä½ å¯èƒ½æ­£åœ¨å­•è‚²ä¸€ä¸ªæ–°çš„è®¡åˆ’ï¼Œæˆ–è€…äº«å—ç”Ÿæ´»ä¸­çš„ç¾å¥½äº‹ç‰©ã€‚è¿™æ˜¯ä¸€ä¸ªå……æ»¡å…³æ€€ä¸æˆé•¿çš„æ—¶æœŸã€‚" },
            4: { name: "çš‡å¸ (The Emperor)", keys: "æƒå¨ã€ç»“æ„ã€æ§åˆ¶ã€çˆ¶äº²å½¢è±¡", desc: "çš‡å¸è±¡å¾ç€ç§©åºä¸è§„åˆ™ã€‚ç°åœ¨éœ€è¦å»ºç«‹ç»“æ„ï¼Œè¿ç”¨é€»è¾‘å’Œçºªå¾‹æ¥å¤„ç†é—®é¢˜ã€‚è¿™æ˜¯ä¸€ä¸ªå·©å›ºåŸºç¡€ã€ç¡®ç«‹æƒå¨çš„æ—¶åˆ»ã€‚" },
            5: { name: "æ•™çš‡ (The Hierophant)", keys: "ä¼ ç»Ÿã€ç²¾ç¥æŒ‡å¼•ã€ä¿¡ä»°ã€æ•™è‚²", desc: "æ•™çš‡ä»£è¡¨ç€æ—¢å®šçš„ä¼ ç»Ÿå’Œä¿¡ä»°ä½“ç³»ã€‚ä½ å¯èƒ½éœ€è¦å¯»æ±‚å¯¼å¸ˆçš„æŒ‡å¼•ï¼Œæˆ–è€…éµå¾ªä¼ ç»Ÿçš„è·¯å¾„æ¥è§£å†³é—®é¢˜ã€‚" },
            6: { name: "æ‹äºº (The Lovers)", keys: "çˆ±ã€å’Œè°ã€å…³ç³»ã€ä»·å€¼è§‚é€‰æ‹©", desc: "æ‹äººä¸ä»…ä»£è¡¨çˆ±æƒ…ï¼Œä¹Ÿä»£è¡¨é‡å¤§çš„é€‰æ‹©ã€‚ä½ éœ€è¦åœ¨ä¸¤ä¸ªæ–¹é¢ä¹‹é—´åšå‡ºå†³å®šï¼Œè¿™é€šå¸¸å…³ä¹ä½ çš„ä»·å€¼è§‚å’ŒçœŸæ­£æ¸´æœ›çš„ä¸œè¥¿ã€‚" },
            7: { name: "æˆ˜è½¦ (The Chariot)", keys: "æ„å¿—åŠ›ã€èƒœåˆ©ã€å†³å¿ƒã€æ–¹å‘", desc: "æˆ˜è½¦ä»£è¡¨é€šè¿‡æ„å¿—åŠ›å…‹æœéšœç¢ã€‚åªè¦ä½ ä¿æŒä¸“æ³¨å¹¶æ§åˆ¶å¥½ç›¸äº’å†²çªçš„åŠ›é‡ï¼Œèƒœåˆ©å°±åœ¨å‰æ–¹ã€‚" },
            8: { name: "åŠ›é‡ (Strength)", keys: "å‹‡æ°”ã€è€å¿ƒã€å†…åœ¨åŠ›é‡ã€åŒæƒ…", desc: "çœŸæ­£çš„åŠ›é‡ä¸æ˜¯æ­¦åŠ›ï¼Œè€Œæ˜¯å†…å¿ƒçš„åšéŸ§ã€‚ç”¨è€å¿ƒå’ŒåŒæƒ…å¿ƒå»é©¯æœå†…å¿ƒçš„é‡å…½ï¼Œä½ å°†èƒ½å¤Ÿå…‹æœä»»ä½•å›°éš¾ã€‚" },
            9: { name: "éšå£« (The Hermit)", keys: "å†…çœã€å­¤ç‹¬ã€å¯»æ±‚çœŸç†ã€æŒ‡å¼•", desc: "éšå£«å»ºè®®ä½ æš‚æ—¶ä»å–§åš£ä¸­æ’¤é€€ï¼Œç‹¬è‡ªå¯»æ‰¾å†…å¿ƒçš„å…‰èŠ’ã€‚è¿™ä¸ä»…ä»…æ˜¯å­¤ç‹¬ï¼Œè€Œæ˜¯ä¸€æ®µè‡ªæˆ‘å‘ç°çš„å¿…è¦æ—…ç¨‹ã€‚" },
            10: { name: "å‘½è¿ä¹‹è½® (Wheel of Fortune)", keys: "æ”¹å˜ã€å‘¨æœŸã€å‘½è¿ã€è½¬æŠ˜ç‚¹", desc: "å‘½è¿ä¹‹è½®åœ¨è½¬åŠ¨ï¼Œç”Ÿæ´»å……æ»¡äº†èµ·ä¼ã€‚è¿™æ˜¯ä¸€ä¸ªä¸å¯é¿å…çš„æ”¹å˜æ—¶åˆ»ï¼Œè¯·é¡ºåº”æ½®æµï¼Œç›¸ä¿¡å®‡å®™çš„å®‰æ’ã€‚" },
            11: { name: "æ­£ä¹‰ (Justice)", keys: "å…¬å¹³ã€çœŸç†ã€å› æœã€æ³•å¾‹", desc: "æ­£ä¹‰ä»£è¡¨ç€å› æœå¾ªç¯ã€‚ä½ ç§ä¸‹ä»€ä¹ˆå› ï¼Œå°±ä¼šæ”¶è·ä»€ä¹ˆæœã€‚è¿™æ˜¯ä¸€ä¸ªéœ€è¦è¯šå®é¢å¯¹è‡ªå·±å’Œä»–äººï¼Œåšå‡ºå…¬æ­£å†³å®šçš„æ—¶åˆ»ã€‚" },
            12: { name: "å€’åŠäºº (The Hanged Man)", keys: "ç‰ºç‰²ã€æ¢ä¸ªè§’åº¦ã€ç­‰å¾…ã€æ”¾ä¸‹", desc: "äº‹æƒ…å¯èƒ½åœæ»ä¸å‰ï¼Œä½†è¿™æ­£æ˜¯æ¢ä¸ªè§’åº¦çœ‹ä¸–ç•Œçš„æœºä¼šã€‚æœ‰æ—¶å€™ï¼Œæ”¾ä¸‹æ§åˆ¶ï¼Œç¨å¾®ç‰ºç‰²ä¸€ä¸‹ï¼Œåè€Œèƒ½è·å¾—æ›´å¤§çš„æ™ºæ…§ã€‚" },
            13: { name: "æ­»ç¥ (Death)", keys: "ç»“æŸã€è½¬å˜ã€é‡ç”Ÿã€æ”¾æ‰‹", desc: "ä¸è¦å®³æ€•ï¼Œæ­»ç¥å¾ˆå°‘ä»£è¡¨è‚‰ä½“çš„æ­»äº¡ï¼Œè€Œæ˜¯è±¡å¾ç€æŸä¸ªé˜¶æ®µçš„ç»“æŸã€‚åªæœ‰æ¸…ç†æ—§çš„ï¼Œæ–°çš„äº‹ç‰©æ‰èƒ½ç”Ÿé•¿ã€‚" },
            14: { name: "èŠ‚åˆ¶ (Temperance)", keys: "å¹³è¡¡ã€é€‚åº¦ã€è€å¿ƒã€æ²»æ„ˆ", desc: "èŠ‚åˆ¶æé†’æˆ‘ä»¬è¦å¯»æ‰¾ä¸­åº¸ä¹‹é“ã€‚é€šè¿‡èåˆå¯¹ç«‹çš„åŠ›é‡ï¼Œä¿æŒè€å¿ƒå’Œå¹³è¡¡ï¼Œä½ å°†æ‰¾åˆ°å†…å¿ƒçš„å¹³é™ã€‚" },
            15: { name: "æ¶é­” (The Devil)", keys: "æŸç¼šã€ç‰©è´¨ä¸»ä¹‰ã€è¯±æƒ‘ã€æˆç˜¾", desc: "æ¶é­”ä»£è¡¨æˆ‘ä»¬è¢«è‡ªå·±çš„æ¬²æœ›æˆ–ææƒ§æ‰€æŸç¼šã€‚æ„è¯†åˆ°è¿™äº›é”é“¾å…¶å®æ˜¯æ¾å¼€çš„ï¼Œä½ éšæ—¶å¯ä»¥é€‰æ‹©è§£è„±ã€‚" },
            16: { name: "é«˜å¡” (The Tower)", keys: "çªå˜ã€ç¾éš¾ã€è§‰é†’ã€ç ´å", desc: "é«˜å¡”ä»£è¡¨çªå¦‚å…¶æ¥çš„å‰§å˜ã€‚è™½ç„¶ç—›è‹¦ï¼Œä½†å®ƒæ‘§æ¯äº†å»ºç«‹åœ¨è™šå‡åŸºç¡€ä¸Šçš„äº‹ç‰©ã€‚è¿™æ˜¯ä¸ºäº†è®©ä½ é‡å»ºå¾—æ›´çœŸå®ã€æ›´åšå›ºã€‚" },
            17: { name: "æ˜Ÿæ˜Ÿ (The Star)", keys: "å¸Œæœ›ã€çµæ„Ÿã€å®é™ã€ç–—æ„ˆ", desc: "åœ¨é£æš´ä¹‹åï¼Œæ˜Ÿæ˜Ÿå¸¦æ¥äº†å¸Œæœ›ä¸æ²»æ„ˆã€‚è¿™æ˜¯ä¸€ä¸ªå……æ»¡çµæ„Ÿå’Œå®é™çš„æ—¶åˆ»ï¼Œç›¸ä¿¡æœªæ¥ï¼Œä¿æŒä¿¡å¿ƒã€‚" },
            18: { name: "æœˆäº® (The Moon)", keys: "å¹»è§‰ã€ææƒ§ã€æ½œæ„è¯†ã€ä¸å®‰", desc: "æœˆäº®ä»£è¡¨ç€æ¨¡ç³Šä¸æ¸…å’Œæ½œæ„è¯†çš„ææƒ§ã€‚äº‹æƒ…å¯èƒ½ä¸åƒè¡¨é¢çœ‹èµ·æ¥é‚£æ ·ã€‚è¯·ç›¸ä¿¡ä½ çš„ç›´è§‰ï¼Œç©¿è¿‡è¿·é›¾ã€‚" },
            19: { name: "å¤ªé˜³ (The Sun)", keys: "å¿«ä¹ã€æˆåŠŸã€æ´»åŠ›ã€ç§¯æ", desc: "å¤ªé˜³æ˜¯å¡”ç½—ç‰Œä¸­æœ€ç§¯æçš„ç‰Œä¹‹ä¸€ã€‚å®ƒé¢„ç¤ºç€æˆåŠŸã€å¿«ä¹å’Œæ¸…æ™°ã€‚äº«å—å½“ä¸‹çš„æ¸©æš–å’Œæ´»åŠ›å§ï¼" },
            20: { name: "å®¡åˆ¤ (Judgement)", keys: "é‡ç”Ÿã€å¬å”¤ã€è§‰é†’ã€å®½æ•", desc: "å®¡åˆ¤ä»£è¡¨ç€ä¸€ä¸ªé‡è¦çš„åå­—è·¯å£ã€‚é€šè¿‡åæ€è¿‡å»ï¼Œå®½æ•è‡ªå·±ï¼Œä½ å°†å“åº”å†…å¿ƒçš„å¬å”¤ï¼Œè·å¾—æ–°ç”Ÿã€‚" },
            21: { name: "ä¸–ç•Œ (The World)", keys: "å®Œæˆã€æ•´åˆã€æˆå°±ã€æ—…è¡Œ", desc: "ä¸–ç•Œä»£è¡¨ä¸€ä¸ªå‘¨æœŸçš„å®Œç¾ç»“æŸã€‚ä½ å·²ç»å®Œæˆäº†ç›®æ ‡ï¼Œç°åœ¨æ˜¯äº«å—æˆå°±ã€å‡†å¤‡å¼€å¯æ–°ç¯‡ç« çš„æ—¶åˆ»ã€‚" },
        };

        // --- è¾…åŠ©å‡½æ•°ï¼šè·å–ç‰Œå ---
        function getCardData(index) {
            index = parseInt(index);
            // å¤§é˜¿å¡çº³
            if (index <= 21) {
                return TAROT_DATA[index] || { name: "å¤§é˜¿å¡çº³ " + index, keys: "æœªçŸ¥", desc: "ç¥ç§˜çš„åŠ›é‡æ­£åœ¨æ˜¾ç°..." };
            }
            // ç®€å•å¤„ç†å°é˜¿å¡çº³ (æƒæ–/åœ£æ¯/å®å‰‘/æ˜Ÿå¸) - 22-77
            const suits = ["æƒæ–", "åœ£æ¯", "å®å‰‘", "æ˜Ÿå¸"];
            const ranks = ["é¦–ç‰Œ (Ace)", "äºŒ (Two)", "ä¸‰ (Three)", "å›› (Four)", "äº” (Five)", "å…­ (Six)", "ä¸ƒ (Seven)", "å…« (Eight)", "ä¹ (Nine)", "å (Ten)", "ä¾ä» (Page)", "éª‘å£« (Knight)", "ç‹å (Queen)", "å›½ç‹ (King)"];
            
            const minorIndex = index - 22;
            const suitIndex = Math.floor(minorIndex / 14);
            const rankIndex = minorIndex % 14;

            if (suitIndex < 4) {
                const suit = suits[suitIndex];
                const rank = ranks[rankIndex];
                // ç®€å•çš„é€šç”¨é‡Šä¹‰
                const genericDesc = `è¿™æ˜¯${suit}ç‰Œç»„çš„${rank}ã€‚${suit}é€šå¸¸ä»£è¡¨${
                    suitIndex===0?"è¡ŒåŠ¨ä¸æ¿€æƒ…":suitIndex===1?"æƒ…æ„Ÿä¸å…³ç³»":suitIndex===2?"æ€æƒ³ä¸å†²çª":"ç‰©è´¨ä¸ç°å®"
                }ã€‚`;
                
                return {
                    name: `${suit}${rank}`,
                    keys: `${suit}, ${rankIndex+1}`,
                    desc: genericDesc + " (è¯·ç»“åˆå…·ä½“é—®é¢˜è¿›è¡Œç›´è§‰è§£è¯»)"
                };
            }
            return { name: "æœªçŸ¥å¡ç‰Œ", keys: "Unknown", desc: "è™šç©ºä¸­çš„è¿·é›¾..." };
        }

        function log(msg) { const d = document.getElementById('debug-console'); d.innerHTML = `> ${msg}<br>` + d.innerHTML; }

        const CONFIG = {
            cardCount: 24, radius: 11.0, rotateSpeed: 1.5, starCount: 2000,
            bloomStrength: 0.15, bloomThreshold: 0.1, damping: 0.94, pullDistance: 2.5,   
            backTextureUrl: './assets/back.jpg', tarotBaseUrl: './assets/', 
            deck: [], colors: { gold: 0xd4af37 },
            minGrabTime: 300 
        };

        let scene, camera, renderer, composer, cardGroup, starField;
        let cards = [], particles = [], raycaster = new THREE.Raycaster();
        let textureLoader, handCoords = new THREE.Vector2(), prevHandX = 0, rotationVelocity = 0, currentGesture = 'NONE';
        let hoveredCard = null, heldCard = null;
        let cursorEl = document.getElementById('hand-cursor');
        let statusGesture = document.getElementById('gesture-text');
        let statusAction = document.getElementById('action-text');
        let isGameReady = false;
        let grabStartTime = 0; let isPinchingState = false;

        init();

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000); scene.fog = new THREE.FogExp2(0x000000, 0.02);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100); camera.position.set(0, 0, 0);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.2); scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(0, 10, 0); scene.add(dirLight);
            const camLight = new THREE.PointLight(0xffffff, 0.5, 20); camera.add(camLight); scene.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.toneMapping = THREE.CineonToneMapping;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = CONFIG.bloomStrength; bloomPass.radius = 0.4; bloomPass.threshold = CONFIG.bloomThreshold;
            composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);

            createStarfield(); loadAssetsAndStart();
            window.addEventListener('resize', onWindowResize); animate();
        }

        function loadAssetsAndStart() {
            textureLoader = new THREE.TextureLoader(); textureLoader.crossOrigin = null;
            textureLoader.load(CONFIG.backTextureUrl, (backTex) => {
                document.getElementById('load-progress').style.width = '50%';
                createCardRing(backTex); startCamera();
            }, undefined, (err) => { log("Back texture error."); });
        }

        function createCardRing(backTex) {
            cardGroup = new THREE.Group(); cardGroup.frustumCulled = false; scene.add(cardGroup);
            
            // [åœ†è§’ä¿®å¤] å°† radius è°ƒæ•´ä¸º 0.2ï¼Œå¹¶æé«˜ segments åˆ° 8ï¼Œç¡®ä¿åœ†è§’å¹³æ»‘
            const geometry = new RoundedBoxGeometry(1.8, 3.0, 0.04, 8, 0.2); 
            
            const matSide = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.3, metalness: 0.8 });
            const matBack = new THREE.MeshStandardMaterial({ map: backTex, color: 0xffffff, roughness: 0.6, metalness: 0.2, emissive: 0x000000 });

            let fullDeck = []; for (let i = 0; i <= 77; i++) fullDeck.push(i);
            for (let i = fullDeck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [fullDeck[i], fullDeck[j]] = [fullDeck[j], fullDeck[i]]; }

            let loadedCount = 0;
            for (let i = 0; i < CONFIG.cardCount; i++) {
                const cardID = fullDeck[i]; const fileName = cardID + ".jpg"; const frontUrl = CONFIG.tarotBaseUrl + fileName;
                const matFront = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.6 });
                
                textureLoader.load(frontUrl, (tex) => {
                    matFront.map = tex; matFront.color.setHex(0xffffff); matFront.needsUpdate = true;
                    loadedCount++;
                    if(loadedCount >= 5 && !isGameReady) { isGameReady = true; document.getElementById('loader').style.display = 'none'; }
                }, undefined, () => { loadedCount++; if(loadedCount >= 5 && !isGameReady) { isGameReady = true; document.getElementById('loader').style.display = 'none'; } });

                const materials = [matSide, matSide, matSide, matSide, matBack, matFront];
                const card = new THREE.Mesh(geometry, materials);
                card.frustumCulled = false;
                const angle = (i / CONFIG.cardCount) * Math.PI * 2;
                const x = Math.sin(angle) * CONFIG.radius; const z = Math.cos(angle) * CONFIG.radius;
                card.position.set(x, -1, -z); card.lookAt(0, -1, 0);
                card.userData = { id: i, cardID: cardID, basePos: card.position.clone(), baseRot: card.rotation.clone(), isDissolving: false, isRevealed: false };
                cardGroup.add(card); cards.push(card);
            }
        }

        function createStarfield() {
            const geo = new THREE.BufferGeometry(); const pos = [];
            for(let i=0; i<CONFIG.starCount; i++) pos.push((Math.random()-0.5)*100, (Math.random()-0.5)*60, (Math.random()-0.5)*100);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({color: 0xffffff, size: 0.1, transparent: true, opacity: 0.5});
            starField = new THREE.Points(geo, mat); starField.frustumCulled = false; scene.add(starField);
        }

        function updateLogic() {
            const sx = (handCoords.x + 1) / 2 * window.innerWidth; const sy = (-handCoords.y + 1) / 2 * window.innerHeight;
            cursorEl.style.transform = `translate(${sx}px, ${sy}px) translate(-50%, -50%)`;
            if(starField) starField.rotation.y += 0.0002;
            raycaster.setFromCamera(handCoords, camera);
            if(cards.length > 0) {
                const intersects = raycaster.intersectObjects(cards);
                if (intersects.length > 0 && !heldCard) {
                    const target = intersects[0].object;
                    if (hoveredCard !== target && !target.userData.isDissolving && !target.userData.isRevealed) {
                        if (hoveredCard) animateHover(hoveredCard, false);
                        hoveredCard = target; animateHover(hoveredCard, true);
                    }
                } else if (!heldCard && hoveredCard) { animateHover(hoveredCard, false); hoveredCard = null; }
            }
            handleGestures();
            if (!heldCard && cardGroup) { 
                cardGroup.rotation.y += rotationVelocity; rotationVelocity *= CONFIG.damping; 
                if (Math.abs(rotationVelocity) < 0.0001) rotationVelocity = 0;
            }
        }

        function handleGestures() {
            statusGesture.innerText = currentGesture;
            if (currentGesture === 'PINCH') {
                statusAction.innerText = "HOLDING"; cursorEl.className = 'pinch'; rotationVelocity *= 0.5; 
                if (hoveredCard && !heldCard) grabCard(hoveredCard);
            } else if (currentGesture === 'OPEN') {
                cursorEl.className = '';
                if (heldCard) {
                    const duration = Date.now() - grabStartTime;
                    if (duration < CONFIG.minGrabTime) {
                        statusAction.innerText = "CANCELED"; returnCard(heldCard);
                    } else {
                        statusAction.innerText = "REVEAL!"; revealAndExplodeInPlace(heldCard);
                    }
                    heldCard = null;
                } else {
                    statusAction.innerText = "ROTATE";
                    const deltaX = handCoords.x - prevHandX;
                    if (Math.abs(deltaX) > 0.0005) rotationVelocity = -deltaX * CONFIG.rotateSpeed;
                }
            }
            prevHandX = handCoords.x;
        }

        function animateHover(c, h) {
            const scale = h ? 1.1 : 1.0; new TWEEN.Tween(c.scale).to({ x:scale, y:scale, z:scale }, 200).start();
        }
        function grabCard(c) {
            heldCard = c; grabStartTime = Date.now();
            const t = c.userData.basePos.clone().add(c.userData.basePos.clone().normalize().multiplyScalar(-CONFIG.pullDistance)); t.y += 0.5; 
            new TWEEN.Tween(c.position).to(t, 300).easing(TWEEN.Easing.Back.Out).start();
        }
        function returnCard(c) {
            new TWEEN.Tween(c.position).to(c.userData.basePos, 500).easing(TWEEN.Easing.Elastic.Out).start();
        }

        // --- æ ¸å¿ƒï¼šç¿»ç‰Œå¹¶æ˜¾ç¤ºè§£è¯» ---
        function revealAndExplodeInPlace(c) {
            c.userData.isRevealed = true;
            
            // 1. è·å–ç‰Œä¹‰
            const cardData = getCardData(c.userData.cardID);
            
            // 2. æ˜¾ç¤ºåˆ°å·¦ä¸Šè§’é¢æ¿
            const panel = document.getElementById('reading-panel');
            document.getElementById('reading-title').innerText = cardData.name;
            document.getElementById('reading-keywords').innerText = cardData.keys;
            document.getElementById('reading-text').innerText = cardData.desc;
            panel.style.opacity = 1;

            // 3. æ·»åŠ å†å²
            addToHistory(cardData.name);

            // 4. æ—‹è½¬åŠ¨ç”» (å¼ºåˆ¶æ­£ä½)
            const dummy = new THREE.Object3D(); dummy.position.copy(c.position); dummy.lookAt(camera.position); 
            const targetRot = dummy.rotation.clone(); targetRot.y += Math.PI; targetRot.z = 0;

            new TWEEN.Tween(c.rotation).to({x: targetRot.x, y: targetRot.y, z: targetRot.z}, 800).easing(TWEEN.Easing.Back.Out).start();
            new TWEEN.Tween(c.scale).to({x:1.3, y:1.3, z:1.3}, 800).start();
            
            // 5. 3ç§’åé”€æ¯
            setTimeout(() => { explodeCard(c); }, 3000);
        }

        function addToHistory(name) {
            const list = document.getElementById('history-list');
            const li = document.createElement('li'); li.className = 'history-item';
            const now = new Date();
            const timeStr = `${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}`;
            li.innerHTML = `<span>${name}</span> <span class="history-time">${timeStr}</span>`;
            list.prepend(li);
        }

        function explodeCard(c) {
            if(c.userData.isDissolving) return;
            c.userData.isDissolving = true; 
            createExplosion(c);
            
            // éšè—è§£è¯»é¢æ¿
            document.getElementById('reading-panel').style.opacity = 0;

            c.visible = false; c.position.set(999, 999, 999);
        }

        function createExplosion(m) {
            const count = 800; const geo = new THREE.BufferGeometry(); const pos = [], vel = []; const wp = new THREE.Vector3(); m.getWorldPosition(wp);
            for(let i=0;i<count;i++){ 
                pos.push(wp.x+(Math.random()-.5)*1.8, wp.y+(Math.random()-.5)*2.8, wp.z); 
                vel.push((Math.random()-.5)*0.15, (Math.random()-.5)*0.15, (Math.random()-.5)*0.15); 
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const p = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.08, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending }));
            p.userData={vel:vel, life:1}; scene.add(p); particles.push(p);
        }

        function updateParticles() {
            for(let i=particles.length-1;i>=0;i--){
                let p=particles[i]; p.userData.life -= 0.02; 
                const pos=p.geometry.attributes.position.array, v=p.userData.vel;
                for(let j=0;j<pos.length/3;j++){ pos[j*3]+=v[j*3]; pos[j*3+1]+=v[j*3+1]; pos[j*3+2]+=v[j*3+2]; }
                p.geometry.attributes.position.needsUpdate=true; p.material.opacity = p.userData.life * 0.7; 
                if(p.userData.life<=0){ scene.remove(p); particles.splice(i,1); }
            }
        }

        async function startCamera() {
            const v = document.querySelector('.input_video');
            const h = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            h.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7});
            h.onResults(res => {
                if(res.multiHandLandmarks.length>0){
                    const lm=res.multiHandLandmarks[0], idx=lm[8], thm=lm[4];
                    handCoords.x += ((1-idx.x)*2-1 - handCoords.x)*0.3; handCoords.y += (-(idx.y*2-1) - handCoords.y)*0.3;
                    const dist = Math.hypot(idx.x-thm.x, idx.y-thm.y);
                    if (isPinchingState) { if (dist > 0.08) isPinchingState = false; } else { if (dist < 0.04) isPinchingState = true; }
                    currentGesture = isPinchingState ? 'PINCH' : 'OPEN';
                }
            });
            const cam = new Camera(v, {onFrame: async () => await h.send({image:v}), width:640, height:480});
            await cam.start();
        }
        function onWindowResize() { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); }
        function animate(t) { requestAnimationFrame(animate); TWEEN.update(t); updateLogic(); updateParticles(); composer.render(); }
    </script>
</body>
</html>