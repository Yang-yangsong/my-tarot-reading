<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarot - Fate Revelation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: none; font-family: "Microsoft YaHei", sans-serif; }
        #debug-console { position: absolute; bottom: 10px; left: 10px; width: 300px; max-height: 100px; background: rgba(0,0,0,0.5); color: #444; font-size: 10px; pointer-events: none; overflow: hidden; border: none; }
        
        /* UI 容器 */
        #ui-container { position: absolute; top: 30px; left: 30px; z-index: 10; display: flex; flex-direction: column; gap: 10px; pointer-events: none; max-width: 350px; }
        .status-box { border-left: 3px solid #d4af37; background: rgba(0,0,0,0.7); padding: 8px 15px; color: #d4af37; font-size: 12px; letter-spacing: 1px; width: fit-content; backdrop-filter: blur(4px); }
        .highlight { color: #fff; font-weight: bold; }
        
        /* 右上角大牌名展示 */
        #reveal-overlay {
            position: absolute; top: 30px; right: 30px; z-index: 20;
            text-align: right; pointer-events: none; opacity: 0;
            transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1), transform 0.8s ease;
            transform: translateX(20px);
        }
        #reveal-overlay.active { opacity: 1; transform: translateX(0); }
        #reveal-card-name {
            font-size: 56px; font-weight: bold; color: #fff;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.8), 0 0 30px rgba(212, 175, 55, 0.4);
            margin-bottom: 5px;
        }
        #reveal-card-suit { font-size: 18px; color: #d4af37; letter-spacing: 5px; text-transform: uppercase; }

        /* 左上角详细解读面板 */
        #reading-panel { margin-top: 10px; background: rgba(0, 0, 0, 0.85); border: 1px solid rgba(212, 175, 55, 0.5); border-radius: 8px; padding: 20px; opacity: 0; transition: opacity 0.5s; box-shadow: 0 0 30px rgba(0,0,0,1); }
        #reading-title { color: #fff; font-size: 24px; font-weight: bold; margin-bottom: 5px; border-bottom: 1px solid #d4af37; padding-bottom: 10px; }
        #reading-keywords { color: #d4af37; font-size: 12px; margin-bottom: 15px; letter-spacing: 1px; }
        #reading-text { color: #ddd; font-size: 14px; line-height: 1.6; text-align: justify; }

        /* 历史记录 */
        #history-panel { margin-top: 10px; width: 100%; background: rgba(0, 0, 0, 0.4); border-radius: 4px; padding: 10px; }
        #history-list { list-style: none; padding: 0; margin: 0; max-height: 120px; overflow-y: hidden; display: flex; flex-direction: column-reverse; }
        .history-item { color: #888; font-size: 12px; padding: 3px 0; border-bottom: 1px dashed rgba(255,255,255,0.05); display: flex; justify-content: space-between; }
        
        /* 指示球 */
        #hand-cursor { position: absolute; width: 20px; height: 20px; border: 2px solid rgba(255, 255, 255, 0.9); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 999; box-shadow: 0 0 8px rgba(255, 255, 255, 0.4); transition: background 0.2s, box-shadow 0.2s; }
        #hand-cursor.pinch { background: rgba(0, 255, 255, 0.8) !important; border-color: #00ffff !important; box-shadow: 0 0 20px #00ffff !important; width: 15px; height: 15px; }

        .input_video { display: none; }
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 1000; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #d4af37; letter-spacing: 4px; font-size: 14px; transition: opacity 0.5s; }
        .loading-bar { width: 150px; height: 1px; background: #333; margin-top: 20px; }
        .progress { width: 0%; height: 100%; background: #d4af37; transition: width 0.2s; }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/", "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.1/dist/tween.esm.js" } } </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="loader"><div>STABILIZING FATE...</div><div class="loading-bar"><div class="progress" id="load-progress"></div></div></div>
    <div id="debug-console">System Ready.</div>
    <div id="hand-cursor"></div>
    
    <div id="reveal-overlay">
        <div id="reveal-card-name">愚人</div>
        <div id="reveal-card-suit">The Arcana</div>
    </div>

    <div id="ui-container">
        <div class="status-box">手势: <span id="gesture-text" class="highlight">NONE</span></div>
        <div class="status-box">动作: <span id="action-text" class="highlight">IDLE</span></div>
        <div id="reading-panel"><div id="reading-title">Card</div><div id="reading-keywords">Keywords</div><div id="reading-text">Meaning...</div></div>
        <div id="history-panel"><ul id="history-list"></ul></div>
    </div>
    
    <video class="input_video"></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js'; 
        import TWEEN from '@tweenjs/tween.js';

        const TAROT_DB = {
            0: { n: "愚人", k: "起始、纯真、自发", d: "象征着新旅程的开始。你需要放下恐惧，相信直觉，勇敢迈出第一步。" },
            1: { n: "魔术师", k: "显化、资源、意志", d: "你拥有达成目标所需的一切工具。现在是利用技能将想法转化为现实的最佳时机。" },
            2: { n: "女祭司", k: "直觉、神秘、潜意识", d: "这是一个向内观察的时刻。外部世界没有答案，请静心倾听你内心的声音。" },
            3: { n: "皇后", k: "丰盛、创造、母性", d: "代表着生命力的绽放和物质的富足。适合进行创作或享受自然与美好的生活。" },
            4: { n: "皇帝", k: "权威、秩序、结构", d: "需要建立规则和结构。用逻辑而非情感来决策，展现你的领导力。" },
            5: { n: "教皇", k: "传统、寻求指引、信仰", d: "建议遵循传统的价值观或寻求导师。在一个已有的体系中寻找解决方案。" },
            6: { n: "恋人", k: "关系、价值观、选择", d: "代表着重要的决定。这不仅关于爱情，更关于你内心深处真正的选择。" },
            7: { n: "战车", k: "胜利、意志、自律", d: "通过专注和坚强的意志克服冲突。只要你掌控好相互抵触的力量，胜利就在前方。" },
            8: { n: "力量", k: "勇气、耐性、同情心", d: "真正的力量来自于温柔的坚韧。用爱和耐心去驯服你内心的恐惧。" },
            9: { n: "隐士", k: "内省、孤独、寻求真理", d: "暂时退隐出嘈杂的世界。独自反思会让你获得比外界更深刻的智慧。" },
            10: { n: "命运之轮", k: "改变、周期、必然性", d: "命运在转动，生活充满了起伏。请顺应潮流，不要试图对抗无法控制的改变。" },
            11: { n: "正义", k: "因果、真理、均衡", d: "你将得到你应得的。这是一个诚实面对自己，并为过去的决定负责的时刻。" },
            12: { n: "倒吊人", k: "牺牲、停滞、换位思考", d: "有时候主动停下来才是进步。尝试从完全相反的角度看待当下的困境。" },
            13: { n: "死神", k: "结束、蜕变、重生", d: "不要恐惧。某个阶段正在不可避免地结束，这是为了给新事物腾出空间。" },
            14: { n: "节制", k: "平衡、适度、融合", d: "寻找中庸之道。通过融合对立的元素，你将获得内心的平静与治愈。" },
            15: { n: "恶魔", k: "束缚、物质、执念", d: "你可能被自己的欲望或负面信念锁住了。意识到锁链是松开的，你随时可以自由。" },
            16: { n: "高塔", k: "剧变、觉醒、崩塌", d: "虚假的结构正在坍塌。虽然这很痛苦，但它为你提供了在真实基础上重建的机会。" },
            17: { n: "星星", k: "希望、宁静、疗愈", d: "风暴已经过去。这是一个充满希望的恢复期，相信你的直觉，宇宙在守护你。" },
            18: { n: "月亮", k: "幻觉、焦虑、直觉", d: "事情并非看起来那样。在迷雾中不要惊慌，依靠你最深层的本能去导航。" },
            19: { n: "太阳", k: "成功、活力、清晰", d: "最积极的牌之一。阳光正照耀在你身上，一切都变得明朗且充满喜悦。" },
            20: { n: "审判", k: "觉醒、重生、召唤", d: "这是一个重要的转折点。反思过去，宽恕自己，准备响应灵魂的真实召唤。" },
            21: { n: "世界", k: "完成、整合、成就", d: "一个周期圆满结束。你已经达成了目标，现在是享受成就并开启新篇章的时刻。" }
        };

        function getReading(id) {
            id = parseInt(id);
            if (TAROT_DB[id]) return TAROT_DB[id];
            const suits = ["权杖", "圣杯", "宝剑", "星币"], ranks = ["首牌", "二", "三", "四", "五", "六", "七", "八", "九", "十", "侍从", "骑士", "王后", "国王"];
            const midx = id - 22; const suit = suits[Math.floor(midx / 14)] || "神秘"; const rank = ranks[midx % 14] || "牌灵";
            return { n: suit + rank, k: suit + "元素", d: `这是${suit}牌组的${rank}。代表着当前生活中${suit==="权杖"?"激情与行动":suit==="圣杯"?"情感与连接":suit==="宝剑"?"智慧与冲突":"物质与现实"}的变化。` };
        }

        const CONFIG = { cardCount: 24, radius: 11.0, rotateSpeed: 1.5, damping: 0.94, pullDistance: 2.5, backTextureUrl: './assets/back.jpg', tarotBaseUrl: './assets/', colors: { gold: 0xd4af37 } };
        let scene, camera, renderer, composer, cardGroup, starField, cards = [], particles = [], raycaster = new THREE.Raycaster();
        let textureLoader, handCoords = new THREE.Vector2(), prevHandX = 0, rotationVelocity = 0, currentGesture = 'NONE';
        let hoveredCard = null, isPinchingState = false, wasPinching = false;
        
        let pinchStartTime = 0; 
        const MIN_PINCH_DURATION = 200; 

        let cursorEl = document.getElementById('hand-cursor'), statusGesture = document.getElementById('gesture-text'), statusAction = document.getElementById('action-text'), isGameReady = false;

        init();

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000); 
            // 修改1: 降低雾的浓度，让远处不那么黑 (0.02 -> 0.01)
            scene.fog = new THREE.FogExp2(0x000000, 0.01);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100); camera.position.set(0, 0, 0);
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.3); scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8); dirLight.position.set(0, 10, 0); scene.add(dirLight);
            const camLight = new THREE.PointLight(0xffffff, 0.5, 20); camera.add(camLight); scene.add(camera);
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 

            // 修改2: 移除 CineonToneMapping，还原真实色彩
            renderer.toneMapping = THREE.NoToneMapping; 
            // 修改3: 设置正确的输出色彩空间
            renderer.outputColorSpace = THREE.SRGBColorSpace;

            document.getElementById('canvas-container').appendChild(renderer.domElement);
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 0.15; composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);
            createStarfield(); loadAssetsAndStart();
            window.addEventListener('resize', onWindowResize); animate();
        }

        function loadAssetsAndStart() {
            textureLoader = new THREE.TextureLoader();
            textureLoader.load(CONFIG.backTextureUrl, (backTex) => {
                // 背面也设置正确的色彩空间
                backTex.colorSpace = THREE.SRGBColorSpace;
                document.getElementById('load-progress').style.width = '50%';
                createCardRing(backTex); startCamera();
            }, undefined, (err) => { console.error("Missing back.jpg"); });
        }

        function createCardRing(backTex) {
            cardGroup = new THREE.Group(); cardGroup.frustumCulled = false; scene.add(cardGroup);
            const geometry = new RoundedBoxGeometry(1.8, 3.0, 0.04, 10, 0.25); 
            const matSide = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.3, metalness: 0.8 });
            const matBack = new THREE.MeshStandardMaterial({ map: backTex, color: 0xffffff, roughness: 0.6, metalness: 0.2 });
            let fullDeck = []; for (let i = 0; i <= 77; i++) fullDeck.push(i);
            for (let i = fullDeck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [fullDeck[i], fullDeck[j]] = [fullDeck[j], fullDeck[i]]; }
            for (let i = 0; i < CONFIG.cardCount; i++) {
                const cardID = fullDeck[i]; const frontUrl = CONFIG.tarotBaseUrl + cardID + ".jpg";
                
                // 修改4: 将卡牌正面基础颜色设为纯白，防止变暗
                const matFront = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6 });
                
                textureLoader.load(frontUrl, (tex) => {
                    // 修改5: 显式设置纹理色彩空间为 SRGB，还原图片饱和度
                    tex.colorSpace = THREE.SRGBColorSpace;
                    matFront.map = tex; 
                    matFront.needsUpdate = true;
                    if(i === CONFIG.cardCount - 1) { isGameReady = true; document.getElementById('loader').style.display = 'none'; }
                });
                const materials = [matSide, matSide, matSide, matSide, matBack, matFront];
                const card = new THREE.Mesh(geometry, materials); card.frustumCulled = false;
                const angle = (i / CONFIG.cardCount) * Math.PI * 2;
                const x = Math.sin(angle) * CONFIG.radius; const z = Math.cos(angle) * CONFIG.radius;
                card.position.set(x, -1, -z); card.lookAt(0, -1, 0);
                card.userData = { cardID: cardID, basePos: card.position.clone(), isDissolving: false, isRevealed: false };
                cardGroup.add(card); cards.push(card);
            }
        }

        function createStarfield() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i = 0; i < 1500; i++) { 
                pos.push((Math.random() - 0.5) * 200, (Math.random() - 0.5) * 200, (Math.random() - 0.5) * 200); 
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                color: 0xffffff, 
                size: 0.25,  
                transparent: true, 
                opacity: 0.95 
            });
            starField = new THREE.Points(geo, mat); 
            scene.add(starField);
        }

        function updateLogic() {
            const sx = (handCoords.x + 1) / 2 * window.innerWidth; const sy = (-handCoords.y + 1) / 2 * window.innerHeight;
            cursorEl.style.transform = `translate(${sx}px, ${sy}px) translate(-50%, -50%)`;
            if(starField) starField.rotation.y += 0.0002;
            
            raycaster.setFromCamera(handCoords, camera);
            if(cards.length > 0) {
                const intersects = raycaster.intersectObjects(cards);
                if (intersects.length > 0) {
                    const target = intersects[0].object;
                    if (hoveredCard !== target && !target.userData.isDissolving && !target.userData.isRevealed) {
                        if (hoveredCard) animateCard(hoveredCard, false);
                        hoveredCard = target; 
                        animateCard(hoveredCard, true);
                    }
                } else if (hoveredCard) {
                    animateCard(hoveredCard, false);
                    hoveredCard = null;
                }
            }
            handleGestures();
            if (!isPinchingState && cardGroup) { 
                cardGroup.rotation.y += rotationVelocity; rotationVelocity *= CONFIG.damping; 
            }
        }

        function handleGestures() {
            const isNowPinching = isPinchingState;
            statusGesture.innerText = isNowPinching ? "锁定" : "张开";
            
            if (isNowPinching) {
                if (!wasPinching) pinchStartTime = Date.now();
                statusAction.innerText = "READY TO PICK";
                cursorEl.classList.add('pinch'); 
                rotationVelocity = 0; 
                wasPinching = true;   
            } else {
                cursorEl.classList.remove('pinch'); 
                const pinchDuration = Date.now() - pinchStartTime;
                
                if (wasPinching && pinchDuration > MIN_PINCH_DURATION && hoveredCard && !hoveredCard.userData.isRevealed) {
                    statusAction.innerText = "PICKED!";
                    revealAndRead(hoveredCard);
                    hoveredCard = null;
                } else if (!wasPinching) {
                    statusAction.innerText = "ROTATE";
                    const deltaX = handCoords.x - prevHandX;
                    if (Math.abs(deltaX) > 0.0005) rotationVelocity = -deltaX * CONFIG.rotateSpeed;
                }
                wasPinching = false; 
            }
            prevHandX = handCoords.x;
        }

        function animateCard(c, active) {
            const scale = active ? 1.3 : 1.0;
            const targetPos = active ? 
                c.userData.basePos.clone().add(c.userData.basePos.clone().normalize().multiplyScalar(-CONFIG.pullDistance)) : 
                c.userData.basePos;
            new TWEEN.Tween(c.scale).to({ x:scale, y:scale, z:scale }, 300).easing(TWEEN.Easing.Back.Out).start();
            new TWEEN.Tween(c.position).to({ x:targetPos.x, y:targetPos.y + (active?0.5:0), z:targetPos.z }, 300).start();
        }

        function revealAndRead(c) {
            c.userData.isRevealed = true;
            const data = getReading(c.userData.cardID);
            
            const panel = document.getElementById('reading-panel');
            document.getElementById('reading-title').innerText = data.n;
            document.getElementById('reading-keywords').innerText = data.k;
            document.getElementById('reading-text').innerText = data.d;
            panel.style.opacity = 1;
            
            const overlay = document.getElementById('reveal-overlay');
            document.getElementById('reveal-card-name').innerText = data.n;
            document.getElementById('reveal-card-suit').innerText = data.k.split('、')[0] || "Fate";
            overlay.classList.add('active');

            const list = document.getElementById('history-list');
            const li = document.createElement('li'); li.className = 'history-item';
            li.innerHTML = `<span>${data.n}</span> <span>${new Date().getHours()}:${new Date().getMinutes()}</span>`;
            list.prepend(li);

            const dummy = new THREE.Object3D(); dummy.position.copy(c.position); dummy.lookAt(camera.position); 
            const targetRot = dummy.rotation.clone(); targetRot.y += Math.PI; targetRot.z = 0;
            new TWEEN.Tween(c.rotation).to({x: targetRot.x, y: targetRot.y, z: targetRot.z}, 800).easing(TWEEN.Easing.Back.Out).start();

            setTimeout(() => { 
                overlay.classList.remove('active');
                panel.style.opacity = 0;
                explodeCard(c); 
            }, 2500);
        }

        function explodeCard(c) {
            if(c.userData.isDissolving) return; 
            c.userData.isDissolving = true; 
            
            new TWEEN.Tween(c.scale).to({x:0, y:0, z:0}, 500).easing(TWEEN.Easing.Exponential.In).onComplete(()=>{
                createExplosion(c);
                c.visible = false; 
                c.position.set(999, 999, 999);
            }).start();
        }

        function createExplosion(m) {
            const count = 1200; 
            const geo = new THREE.BufferGeometry(); const pos = [], vel = []; 
            const wp = new THREE.Vector3(); m.getWorldPosition(wp);
            
            for(let i=0; i<count; i++){ 
                pos.push(wp.x+(Math.random()-.5)*1.8, wp.y+(Math.random()-.5)*2.8, wp.z); 
                vel.push((Math.random()-.5)*0.25, (Math.random()-.5)*0.25, (Math.random()-.5)*0.25); 
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const p = new THREE.Points(geo, new THREE.PointsMaterial({ 
                color: 0xffffff, size: 0.1, transparent: true, opacity: 1.0, 
                blending: THREE.AdditiveBlending 
            }));
            p.userData={vel:vel, life:1.5}; 
            scene.add(p); particles.push(p);
        }

        function updateParticles() {
            for(let i=particles.length-1;i>=0;i--){
                let p=particles[i]; 
                p.userData.life -= 0.02; 
                const pos=p.geometry.attributes.position.array, v=p.userData.vel;
                for(let j=0;j<pos.length/3; j++){ 
                    pos[j*3]+=v[j*3]; pos[j*3+1]+=v[j*3+1]; pos[j*3+2]+=v[j*3+2]; 
                }
                p.geometry.attributes.position.needsUpdate=true; 
                p.material.opacity = p.userData.life / 1.5; 
                if(p.userData.life<=0){ scene.remove(p); particles.splice(i,1); }
            }
        }

        async function startCamera() {
            const v = document.querySelector('.input_video');
            const h = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            h.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7});
            h.onResults(res => {
                if(res.multiHandLandmarks.length>0){
                    const lm=res.multiHandLandmarks[0], idx=lm[8], thm=lm[4];
                    handCoords.x += ((1-idx.x)*2-1 - handCoords.x)*0.3; handCoords.y += (-(idx.y*2-1) - handCoords.y)*0.3;
                    const dist = Math.hypot(idx.x-thm.x, idx.y-thm.y);
                    if (isPinchingState) { if (dist > 0.09) isPinchingState = false; } else { if (dist < 0.04) isPinchingState = true; }
                }
            });
            const cam = new Camera(v, {onFrame: async () => await h.send({image:v}), width:640, height:480});
            await cam.start();
        }
        function onWindowResize() { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); }
        function animate(t) { requestAnimationFrame(animate); TWEEN.update(t); updateLogic(); updateParticles(); composer.render(); }
    </script>
</body>
</html>